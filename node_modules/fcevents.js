/**
 * This is a test node module which works on the 
 * same specification as events module of node
 * @module fcevents
 * @author Vishal Baranwal
 * 
 */

(function(exports){

	/**
	 * Name of the error event
	 * @private
	 * @constant
	 */
	var ERROR_EVENT = "error";
	
	/**
	 * Name of the new listener event
	 * @private
	 * @constant
	 */
	var NEW_LISTENER_EVENT = "newListener";
	
	/**
	 * Name of the remove listener event
	 * @private
	 * @constant
	 */
	var REMOVE_LISTENER_EVENT = "removeListener";
	
	/**
	 * Default value of max listeners
	 * @private
	 * @constant
	 */
	var DEFAULT_MAX_LISTENERS = 10;
	
	
	/**
	 * This is the EventEmitter class which contains methods to manage 
	 * publishing and subscribing events
	 * @constructor
	 * @class
	 * @public
	 */
	exports.EventEmitter = function () {
		/**
		 * Map which holds the list of listeners for an event
		 * @private
		 */
		var _eventListenersMap = null;
	
		/**
		 * Maximum number of listeners for emitter.
		 * Defaults to 10
		 * @private
		 */
		var _maxListerners = DEFAULT_MAX_LISTENERS;
	
		/**
		 * Get the arguments for invoking the listener. 
		 * @private
		 * @method
		 * @param {Object} args
		 * @returns Array of arguments for listener call
		 */
		var _getArgumentsForListenerCall = function(args){
			var newArgs = [];
			if(args && args.length > 1){
				var argLength = args.length;
				for(var index = 1; index < argLength; index++){
					newArgs.push(args[index]);
				}
			}
			return newArgs;
		};
	
		/**
		 * Invoke listener for specified event. 
		 * @private
		 * @method
		 */
		var _invokeListener = function(){
			var eventName = arguments[0];
			if(_eventListenersMap && _eventListenersMap[eventName] &&
				_eventListenersMap[eventName].length > 0){
				var args = _getArgumentsForListenerCall(arguments);
				
				var listernerList = _eventListenersMap[eventName];
				for(var index = 0; index < listernerList.length; index++){
					var listernerObject = listernerList[index];
					listernerObject.listerner.apply(this, args);
					if(listernerObject.invokeOnce){
						listernerList.splice(index, 1);
						index--;
					}
				}
			}
		};
	
		/**
		 * Add listener for speficied event 
		 * @private
		 * @method
		 * @param {string} eventName
		 * @param {Object} listerner
		 * @param {Object} options
		 * @returns True if listener was added. False otherwise.
		 */
		var _subscriberListener = function(eventName, listerner, options){
			// Add type of function validation for listerner as well.
			if(!eventName || !listerner){
				var error = "eventName and listerner are both required";
				console.error(error);
				throw error;
			}
			
			if(_eventListenersMap == null){
				_eventListenersMap = {};
			}
			
			if(_eventListenersMap[eventName] == null){
				_eventListenersMap[eventName] = [];
			}
			
			var listernerList = _eventListenersMap[eventName];
			
			if(_maxListerners !== 0 && _maxListerners !== null){
				if(listernerList.length >= _maxListerners){
					var warning = "Max listeners are set to " + _maxListerners +
						". More than " + _maxListerners + " listeners are added";
					console.warn(warning);
				}
			}
			
			var invokeOnce = false;
			if(options && options.invokeOnce === true){
				invokeOnce = true;
			}
			
			var flag = false;
			
			// Check for same listerner existing for the eventName
			if(!_isListenerAdded(listernerList, listerner)){
				listernerList.push({
					listerner: listerner,
					invokeOnce: invokeOnce
				});
				flag = true;
			}
			
			return flag;
		};
	
		/**
		 * Find out whether listener is already added or not for the
		 * specified event 
		 * @private
		 * @method
		 * @param {string} eventName
		 * @param {Object} listerner
		 * @param {Object} options
		 * @returns True if listener is already added. False otherwise.
		 */
		var _isListenerAdded = function(listernerList, listerner){
			var flag = false;
			if(listernerList && listernerList.length > 0){
				var length = listernerList.length;
				for(var index = 0; index < length; index++){
					var listernerObject = listernerList[index];
					if(listernerObject.listerner == listerner){
						flag = true;
						break;
					}
				}
			}
			return flag;
		};
	
		return {
			
			/**
			 * Adds a listener to the event specified. 
			 * @public
			 * @method
			 * @param {string} event
			 * @param {Object} listerner
			 * @returns Reference to event emitter object 
			 */
			on: function(event, listerner){
				try{
					var options = {
						invokeOnce: false
					};
					var flag = _subscriberListener.call(this, event, listerner, options);
					if(flag){
						// Emit newListener
						this.emit(NEW_LISTENER_EVENT, event);
					}
				}
				catch(exception){
					// This check is to ensure that exception on 
					// emiting does not get caught in infinite loop.
					if(event != ERROR_EVENT){
						console.error(exception); // Log the exception		
						this.emit(ERROR_EVENT, exception);
					}
				}
				
				// Returns reference to current object to ensure that chaining works
				return this;
			},
	
			/**
			 * Adds a listener to the event specified
			 * @public
			 * @method
			 * @param {string} event
			 * @param {Object} listerner
			 * @returns Reference to event emitter object 
			 */
			addListener: function(event, listerner){
				return this.on(event, listerner);
			},
			
			/**
			 * Adds a one time listener to the event specified.
			 * Once invocation is done, the listener is removed
			 * @public
			 * @method
			 * @param {string} event
			 * @param {Object} listerner
			 * @returns Reference to event emitter object 
			 */
			once: function(event, listerner){
				try{
					var options = {
						invokeOnce: true
					};
					var flag = _subscriberListener.call(this, event, listerner, options);
					if(flag){
						// Emit newListener
						this.emit(NEW_LISTENER_EVENT, event);
					}
				}
				catch(exception){
					// This check is to ensure that exception on emiting 
					// does not get caught in infinite loop.
					if(event != ERROR_EVENT){
						console.error(exception); // Log the exception
						this.emit(ERROR_EVENT, exception);
					}
				}
				
				// Returns reference to current object to ensure that chaining works
				return this;
			},
			
			/**
			 * Set the maximum number of listeners which event can have
			 * @public
			 * @method
			 * @param {!number} n
			 */
			setMaxListeners: function(n){
				if(typeof n != "number"){
					var error = "Max listeners should be a number";
					console.error(error);
					this.emit(ERROR_EVENT, error);
				}
				else{
					_maxListerners = n;
				}
			},
			
			/**
			 * Execute each listener for the event in order with the supplied argument
			 * @public
			 * @method
			 * @param {string} event
			 * @returns Reference to event emitter object 
			 */
			emit: function(event){
				try{
					_invokeListener.apply(this, arguments);
				}
				catch(exception){
					// Log the exception
					console.error(exception);
					
					// This check is to ensure that exception on 
					// emiting does not get caught in infinite loop.		
					if(event != ERROR_EVENT){
						this.emit(ERROR_EVENT, exception);
					}
				}
	
				// Returns reference to current object to ensure that chaining works
				return this;
			},
	
			/**
			 * Returns an array of listeners for the specified event
			 * @public
			 * @method
			 * @param {string} event
			 * @returns List of listeners for the event
			 */
			listeners: function(event){
				var listeners = null;
				if(event && _eventListenersMap && _eventListenersMap[event] &&
					_eventListenersMap[event].length > 0){
					var listernerList = _eventListenersMap[event];
					listeners = [];
					for(var index = 0; index < listernerList.length; index++){
						var listernerObject = listernerList[index];
						listeners.push(listernerObject.listerner);
					}
				}
				return listeners;
			},
			
			/**
			 * Remove a listener for the specified event
			 * @public
			 * @method
			 * @param {string} event
			 * @param {Object} listener
			 * @returns Reference to event emitter object 
			 */
			removeListener: function(event, listener){
				var flag = false;
				try{
					if(event && listener && _eventListenersMap &&
						_eventListenersMap[event]){
						var listernerList = _eventListenersMap[event];
						for(var index = 0; index < listernerList.length; index++){
							var listernerObject = listernerList[index];
							if(listernerObject.listerner == listener){
								listernerList.splice(index, 1);
								flag = true;
								break;
							}
						}
					}
				}
				catch(exception){
					console.error(exception); // Log the exception		
					this.emit(ERROR_EVENT, exception);
				}
				
				if(flag){
					// Emit removeListener
					this.emit(REMOVE_LISTENER_EVENT, event, listener);
				}
				
				// Returns reference to current object to ensure that chaining works
				return this;
			},
			
			/**
			 * Removes all listener of those of the specified event
			 * @public
			 * @method
			 * @param {string} event
			 * @returns Reference to event emitter object 
			 */
			removeAllListeners: function(event){
				var flag = false;
				try{
					if(!event){
						_eventListenersMap = null;
					}
					else if(_eventListenersMap && _eventListenersMap[event]){
						_eventListenersMap[event] = null;
					}
					
					flag = false;
				}
				catch(exception){
					console.error(exception); // Log the exception		
					this.emit(ERROR_EVENT, exception);
				}
				
				if(flag){
					// Emit removeListener
					this.emit(REMOVE_LISTENER_EVENT, event);
				}
	
				// Returns reference to current object to ensure that chaining works
				return this;
			}
	
	
		};
	
	};
	
	
	/**
	 * Returns the number of listeners for a given event
	 * @public
	 * @static
	 * @param {Object} emitter
	 * @param {string} event
	 * @returns Count of listeners
	 */
	exports.EventEmitter.listenerCount = function(emitter, event){
		var count = null;
		if(emitter && event){
			var listeners = emitter.listeners(event);
			if(listeners){
				count = listeners.length;
			}
		}
		return count;
	};


})(typeof exports === "undefined"? this.fcevents={}: exports);


